"""Docker container management for SafeYolo."""

import subprocess
import time
from pathlib import Path

from .config import (
    CERTS_VOLUME_NAME,
    INTERNAL_NETWORK_NAME,
    INTERNAL_SUBNET,
    SAFEYOLO_INTERNAL_IP,
    get_certs_dir,
    get_config_dir,
    get_data_dir,
    get_logs_dir,
    get_policies_dir,
    get_rules_path,
    load_config,
)


class DockerError(Exception):
    """Docker operation failed."""

    pass


def _run(args: list[str], check: bool = True, capture: bool = True) -> subprocess.CompletedProcess:
    """Run a command and return result."""
    try:
        result = subprocess.run(
            args,
            check=check,
            capture_output=capture,
            text=True,
        )
        return result
    except subprocess.CalledProcessError as e:
        raise DockerError(f"Command failed: {' '.join(args)}\n{e.stderr}")
    except FileNotFoundError:
        raise DockerError(f"Command not found: {args[0]}")


def check_docker() -> bool:
    """Check if Docker is available."""
    try:
        result = _run(["docker", "version"], check=False)
        return result.returncode == 0
    except DockerError:
        return False


def get_container_name() -> str:
    """Get container name from config."""
    config = load_config()
    return config["proxy"].get("container_name", "safeyolo")


def is_running() -> bool:
    """Check if SafeYolo container is running."""
    name = get_container_name()
    result = _run(
        ["docker", "ps", "-q", "-f", f"name={name}"],
        check=False,
    )
    return bool(result.stdout.strip())


def get_container_status() -> dict | None:
    """Get container status details."""
    name = get_container_name()
    result = _run(
        [
            "docker", "inspect",
            "-f", "{{.State.Status}}|{{.State.Health.Status}}|{{.State.StartedAt}}",
            name,
        ],
        check=False,
    )
    if result.returncode != 0:
        return None

    parts = result.stdout.strip().split("|")
    if len(parts) >= 3:
        return {
            "status": parts[0],
            "health": parts[1] if parts[1] else "none",
            "started_at": parts[2],
        }
    return None


def generate_compose_file() -> str:
    """Generate docker-compose.yml content from config."""
    config = load_config()
    proxy = config["proxy"]
    config_dir = get_config_dir()

    # Resolve paths
    logs_dir = get_logs_dir()
    certs_dir = get_certs_dir()
    policies_dir = get_policies_dir()
    data_dir = get_data_dir()
    rules_path = get_rules_path()

    compose = f"""# Generated by safeyolo CLI
# Do not edit manually - run 'safeyolo init' to regenerate

services:
  safeyolo:
    image: {proxy.get('image', 'safeyolo:latest')}
    container_name: {proxy.get('container_name', 'safeyolo')}
    ports:
      - "{proxy.get('port', 8080)}:8080"
      - "{proxy.get('admin_port', 9090)}:9090"
    volumes:
      - {logs_dir}:/app/logs
      - {certs_dir}:/certs
      - {policies_dir}:/app/data/policies
      - {data_dir}:/app/data
"""

    # Add rules.json if it exists
    if rules_path.exists():
        compose += f"      - {rules_path}:/app/config/credential_rules.json:ro\n"

    # Add policy.yaml if it exists
    policy_path = config_dir / "policy.yaml"
    if policy_path.exists():
        compose += f"      - {policy_path}:/app/config/policy.yaml:ro\n"

    compose += """    environment:
      - SAFEYOLO_BLOCK=true
    restart: unless-stopped
    sysctls:
      - net.ipv6.conf.all.disable_ipv6=1
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9090/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
"""

    return compose


def generate_secure_compose_file() -> str:
    """Generate docker-compose.yml for Secure Mode with network isolation.

    Secure Mode creates an internal Docker network with no internet access.
    SafeYolo bridges between the internal network and the internet, forcing
    all agent traffic through the proxy.
    """
    config = load_config()
    proxy = config["proxy"]
    config_dir = get_config_dir()

    # Resolve paths
    logs_dir = get_logs_dir()
    policies_dir = get_policies_dir()
    data_dir = get_data_dir()
    rules_path = get_rules_path()

    compose = f"""# Generated by safeyolo CLI (Secure Mode)
# Do not edit manually - run 'safeyolo init --secure' to regenerate
#
# Secure Mode: Agent containers on {INTERNAL_NETWORK_NAME} have NO direct
# internet access. All traffic must go through SafeYolo at {SAFEYOLO_INTERNAL_IP}.

services:
  safeyolo:
    image: {proxy.get('image', 'safeyolo:latest')}
    container_name: {proxy.get('container_name', 'safeyolo')}
    networks:
      {INTERNAL_NETWORK_NAME}:
        ipv4_address: {SAFEYOLO_INTERNAL_IP}
      default:
        # Internet access via default bridge
    ports:
      - "127.0.0.1:{proxy.get('port', 8080)}:8080"
      - "127.0.0.1:{proxy.get('admin_port', 9090)}:9090"
    volumes:
      - {logs_dir}:/app/logs
      - {CERTS_VOLUME_NAME}:/certs
      - {policies_dir}:/app/data/policies
      - {data_dir}:/app/data
"""

    # Add rules.json if it exists
    if rules_path.exists():
        compose += f"      - {rules_path}:/app/config/credential_rules.json:ro\n"

    # Add policy.yaml if it exists
    policy_path = config_dir / "policy.yaml"
    if policy_path.exists():
        compose += f"      - {policy_path}:/app/config/policy.yaml:ro\n"

    compose += f"""    environment:
      - SAFEYOLO_BLOCK=true
    restart: unless-stopped
    sysctls:
      - net.ipv6.conf.all.disable_ipv6=1
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9090/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

networks:
  {INTERNAL_NETWORK_NAME}:
    driver: bridge
    internal: true  # No default gateway - agents cannot bypass proxy
    ipam:
      config:
        - subnet: {INTERNAL_SUBNET}

volumes:
  {CERTS_VOLUME_NAME}: {{}}
"""

    return compose


def write_compose_file(secure: bool = False) -> Path:
    """Write docker-compose.yml to config directory.

    Args:
        secure: If True, generate Secure Mode compose with network isolation
    """
    config_dir = get_config_dir(create=True)
    compose_path = config_dir / "docker-compose.yml"

    if secure:
        compose_path.write_text(generate_secure_compose_file())
    else:
        compose_path.write_text(generate_compose_file())

    return compose_path


def start(detach: bool = True, pull: bool = False) -> None:
    """Start SafeYolo container.

    Args:
        detach: Run in background
        pull: Pull latest image first
    """
    if not check_docker():
        raise DockerError("Docker is not available - please install Docker")

    config = load_config()
    secure = config.get("secure", False)
    compose_path = write_compose_file(secure=secure)

    if pull:
        _run(["docker", "compose", "-f", str(compose_path), "pull"])

    args = ["docker", "compose", "-f", str(compose_path), "up"]
    if detach:
        args.append("-d")

    _run(args)


def stop() -> None:
    """Stop SafeYolo container."""
    config_dir = get_config_dir()
    compose_path = config_dir / "docker-compose.yml"

    if not compose_path.exists():
        # Try direct docker stop
        name = get_container_name()
        _run(["docker", "stop", name], check=False)
        return

    _run(["docker", "compose", "-f", str(compose_path), "down"])


def restart() -> None:
    """Restart SafeYolo container."""
    config_dir = get_config_dir()
    compose_path = config_dir / "docker-compose.yml"

    if compose_path.exists():
        _run(["docker", "compose", "-f", str(compose_path), "restart"])
    else:
        stop()
        start()


def logs(follow: bool = False, tail: int | None = None) -> subprocess.Popen | str:
    """Get container logs.

    Args:
        follow: Stream logs continuously
        tail: Number of lines from end

    Returns:
        Popen if follow=True, else log string
    """
    name = get_container_name()
    args = ["docker", "logs"]

    if follow:
        args.append("-f")
    if tail:
        args.extend(["--tail", str(tail)])

    args.append(name)

    if follow:
        # Return process for streaming
        return subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
    else:
        result = _run(args)
        return result.stdout


def wait_for_healthy(timeout: int = 30) -> bool:
    """Wait for container to become healthy.

    Args:
        timeout: Max seconds to wait

    Returns:
        True if healthy, False if timeout
    """
    start_time = time.time()
    while time.time() - start_time < timeout:
        status = get_container_status()
        if status and status.get("health") == "healthy":
            return True
        if status and status.get("status") != "running":
            return False
        time.sleep(1)
    return False
